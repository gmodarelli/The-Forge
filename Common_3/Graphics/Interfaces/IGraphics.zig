// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

pub const DxDescriptorID = i32;

pub const RendererApi = extern struct {
    bits: c_int = 0,

    pub const RENDERER_API_D3D12: RendererApi = .{ .bits = 0 };
    pub const RENDERER_API_COUNT: RendererApi = .{ .bits = 1 };

    // pub usingnamespace cpp.FlagsMixin(RendererApi);
};

pub const QueueType = extern struct {
    bits: c_int = 0,

    pub const QUEUE_TYPE_GRAPHICS: QueueType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const QUEUE_TYPE_TRANSFER: QueueType = .{ .bits = QueueType.QUEUE_TYPE_GRAPHICS.bits + 1 };
    pub const QUEUE_TYPE_COMPUTE: QueueType = .{ .bits = QueueType.QUEUE_TYPE_GRAPHICS.bits + 2 };
    pub const MAX_QUEUE_TYPE: QueueType = .{ .bits = QueueType.QUEUE_TYPE_GRAPHICS.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(QueueType);
};

pub const QueueFlag = extern struct {
    bits: c_int = 0,

    pub const QUEUE_FLAG_NONE: QueueFlag = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const QUEUE_FLAG_DISABLE_GPU_TIMEOUT: QueueFlag = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const QUEUE_FLAG_INIT_MICROPROFILE: QueueFlag = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const MAX_QUEUE_FLAG: QueueFlag = .{ .bits = 4294967295 };

    // pub usingnamespace cpp.FlagsMixin(QueueFlag);
};

pub const QueuePriority = extern struct {
    bits: c_int = 0,

    pub const QUEUE_PRIORITY_NORMAL: QueuePriority = .{ .bits = 0 };
    pub const QUEUE_PRIORITY_HIGH: QueuePriority = .{ .bits = 1 };
    pub const QUEUE_PRIORITY_GLOBAL_REALTIME: QueuePriority = .{ .bits = 2 };
    pub const MAX_QUEUE_PRIORITY: QueuePriority = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(QueuePriority);
};

pub const LoadActionType = extern struct {
    bits: c_int = 0,

    pub const LOAD_ACTION_DONTCARE: LoadActionType = .{ .bits = 0 };
    pub const LOAD_ACTION_LOAD: LoadActionType = .{ .bits = 1 };
    pub const LOAD_ACTION_CLEAR: LoadActionType = .{ .bits = 2 };
    pub const MAX_LOAD_ACTION: LoadActionType = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(LoadActionType);
};

pub const StoreActionType = extern struct {
    bits: c_int = 0,

    /// Store is the most common use case so keep that as default
    pub const STORE_ACTION_STORE: StoreActionType = .{ .bits = 0 };
    /// Store is the most common use case so keep that as default
    pub const STORE_ACTION_DONTCARE: StoreActionType = .{ .bits = 1 };
    /// Store is the most common use case so keep that as default
    pub const STORE_ACTION_NONE: StoreActionType = .{ .bits = 2 };
    pub const MAX_STORE_ACTION: StoreActionType = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(StoreActionType);
};

pub const LogFn = ?*const fn (LogLevel, [*c]const u8, [*c]const u8) callconv(.C) void;

pub const ResourceState = extern struct {
    bits: c_int = 0,

    pub const RESOURCE_STATE_UNDEFINED: ResourceState = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER: ResourceState = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const RESOURCE_STATE_INDEX_BUFFER: ResourceState = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const RESOURCE_STATE_RENDER_TARGET: ResourceState = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const RESOURCE_STATE_UNORDERED_ACCESS: ResourceState = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const RESOURCE_STATE_DEPTH_WRITE: ResourceState = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const RESOURCE_STATE_DEPTH_READ: ResourceState = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const RESOURCE_STATE_PIXEL_SHADER_RESOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const RESOURCE_STATE_SHADER_RESOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(64 | 128)) };
    pub const RESOURCE_STATE_STREAM_OUT: ResourceState = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const RESOURCE_STATE_INDIRECT_ARGUMENT: ResourceState = .{ .bits = @as(c_uint, @intCast(512)) };
    pub const RESOURCE_STATE_COPY_DEST: ResourceState = .{ .bits = @as(c_uint, @intCast(1024)) };
    pub const RESOURCE_STATE_COPY_SOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(2048)) };
    pub const RESOURCE_STATE_GENERIC_READ: ResourceState = .{ .bits = @as(c_uint, @intCast((((((1 | 2) | 64) | 128) | 512) | 2048))) };
    pub const RESOURCE_STATE_PRESENT: ResourceState = .{ .bits = @as(c_uint, @intCast(4096)) };
    pub const RESOURCE_STATE_COMMON: ResourceState = .{ .bits = @as(c_uint, @intCast(8192)) };
    pub const RESOURCE_STATE_ACCELERATION_STRUCTURE_READ: ResourceState = .{ .bits = @as(c_uint, @intCast(16384)) };
    pub const RESOURCE_STATE_ACCELERATION_STRUCTURE_WRITE: ResourceState = .{ .bits = @as(c_uint, @intCast(32768)) };
    pub const RESOURCE_STATE_UNORDERED_ACCESS_PIXEL: ResourceState = .{ .bits = @as(c_uint, @intCast(ResourceState.RESOURCE_STATE_UNORDERED_ACCESS.bits)) };

    // pub usingnamespace cpp.FlagsMixin(ResourceState);
};

/// Choosing Memory Type
pub const ResourceMemoryUsage = extern struct {
    bits: c_int = 0,

    /// No intended memory usage specified.
    pub const RESOURCE_MEMORY_USAGE_UNKNOWN: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Memory will be used on device only, no need to be mapped on host.
    pub const RESOURCE_MEMORY_USAGE_GPU_ONLY: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Memory will be mapped on host. Could be used for transfer to device.
    pub const RESOURCE_MEMORY_USAGE_CPU_ONLY: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(2)) };
    /// Memory will be used for frequent (dynamic) updates from host and reads on device.
    pub const RESOURCE_MEMORY_USAGE_CPU_TO_GPU: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(3)) };
    /// Memory will be used for writing on device and readback on host.
    pub const RESOURCE_MEMORY_USAGE_GPU_TO_CPU: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Memory will be used for writing on device and readback on host.
    pub const RESOURCE_MEMORY_USAGE_COUNT: ResourceMemoryUsage = .{ .bits = ResourceMemoryUsage.RESOURCE_MEMORY_USAGE_GPU_TO_CPU.bits + 1 };
    /// Memory will be used for writing on device and readback on host.
    pub const RESOURCE_MEMORY_USAGE_MAX_ENUM: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(2147483647)) };

    // pub usingnamespace cpp.FlagsMixin(ResourceMemoryUsage);
};

/// Choosing Memory Type
pub const GPUSelection = extern struct {
    /// Available GPU capabilities
    ppAvailableGpuNames: [256][4]u8,
    pAvailableGpuIds: [4]u32,
    mAvailableGpuCount: u32,
    mSelectedGpuIndex: u32,
    /// Could add swap chain size, render target format, ...
    mPreferedGpuId: u32,
};

/// Forward declarations
pub const Renderer = Renderer;

/// Raytracing
pub const IndirectDrawArguments = extern struct {
    mVertexCount: u32,
    mInstanceCount: u32,
    mStartVertex: u32,
    mStartInstance: u32,
};

pub const IndirectDrawIndexArguments = extern struct {
    mIndexCount: u32,
    mInstanceCount: u32,
    mStartIndex: u32,
    mVertexOffset: u32,
    mStartInstance: u32,
};

pub const IndirectDispatchArguments = extern struct {
    mGroupCountX: u32,
    mGroupCountY: u32,
    mGroupCountZ: u32,
};

pub const IndirectArgumentType = extern struct {
    bits: c_int = 0,

    pub const INDIRECT_DRAW: IndirectArgumentType = .{ .bits = 0 };
    pub const INDIRECT_DRAW_INDEX: IndirectArgumentType = .{ .bits = 1 };
    pub const INDIRECT_DISPATCH: IndirectArgumentType = .{ .bits = 2 };
    /// metal ICB
    pub const INDIRECT_COMMAND_BUFFER: IndirectArgumentType = .{ .bits = 3 };
    /// metal ICB reset
    pub const INDIRECT_COMMAND_BUFFER_RESET: IndirectArgumentType = .{ .bits = 4 };
    /// metal ICB optimization
    pub const INDIRECT_COMMAND_BUFFER_OPTIMIZE: IndirectArgumentType = .{ .bits = 5 };

    // pub usingnamespace cpp.FlagsMixin(IndirectArgumentType);
};

///*********************************************
pub const DescriptorType = extern struct {
    bits: c_int = 0,

    pub const DESCRIPTOR_TYPE_UNDEFINED: DescriptorType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const DESCRIPTOR_TYPE_SAMPLER: DescriptorType = .{ .bits = @as(c_uint, @intCast(1)) };
    /// SRV Read only texture
    pub const DESCRIPTOR_TYPE_TEXTURE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_SAMPLER.bits << 1))) };
    /// UAV Texture
    pub const DESCRIPTOR_TYPE_RW_TEXTURE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_TEXTURE.bits << 1))) };
    /// SRV Read only buffer
    pub const DESCRIPTOR_TYPE_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RW_TEXTURE.bits << 1))) };
    /// SRV Read only buffer
    pub const DESCRIPTOR_TYPE_BUFFER_RAW: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_BUFFER.bits | (DescriptorType.DESCRIPTOR_TYPE_BUFFER.bits << 1)))) };
    /// UAV Buffer
    pub const DESCRIPTOR_TYPE_RW_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_BUFFER.bits << 2))) };
    /// UAV Buffer
    pub const DESCRIPTOR_TYPE_RW_BUFFER_RAW: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits | (DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits << 1)))) };
    /// Uniform buffer
    pub const DESCRIPTOR_TYPE_UNIFORM_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits << 2))) };
    /// Push constant / Root constant
    pub const DESCRIPTOR_TYPE_ROOT_CONSTANT: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_UNIFORM_BUFFER.bits << 1))) };
    /// IA
    pub const DESCRIPTOR_TYPE_VERTEX_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_ROOT_CONSTANT.bits << 1))) };
    /// IA
    pub const DESCRIPTOR_TYPE_INDEX_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_VERTEX_BUFFER.bits << 1))) };
    /// IA
    pub const DESCRIPTOR_TYPE_INDIRECT_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_INDEX_BUFFER.bits << 1))) };
    /// Cubemap SRV
    pub const DESCRIPTOR_TYPE_TEXTURE_CUBE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_TEXTURE.bits | (DescriptorType.DESCRIPTOR_TYPE_INDIRECT_BUFFER.bits << 1)))) };
    /// RTV / DSV per mip slice
    pub const DESCRIPTOR_TYPE_RENDER_TARGET_MIP_SLICES: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_INDIRECT_BUFFER.bits << 2))) };
    /// RTV / DSV per array slice
    pub const DESCRIPTOR_TYPE_RENDER_TARGET_ARRAY_SLICES: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RENDER_TARGET_MIP_SLICES.bits << 1))) };
    /// RTV / DSV per depth slice
    pub const DESCRIPTOR_TYPE_RENDER_TARGET_DEPTH_SLICES: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RENDER_TARGET_ARRAY_SLICES.bits << 1))) };
    /// RTV / DSV per depth slice
    pub const DESCRIPTOR_TYPE_INDIRECT_COMMAND_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RENDER_TARGET_DEPTH_SLICES.bits << 1))) };
    /// Raytracing acceleration structure
    pub const DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_INDIRECT_COMMAND_BUFFER.bits << 1))) };
    /// Mask for UAV resources
    pub const DESCRIPTOR_TYPE_RW_MASK: DescriptorType = .{ .bits = @as(c_uint, @intCast(DescriptorType.DESCRIPTOR_TYPE_RW_TEXTURE.bits | DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits)) };

    // pub usingnamespace cpp.FlagsMixin(DescriptorType);
};

///*********************************************
pub const SampleCount = extern struct {
    bits: c_int = 0,

    pub const SAMPLE_COUNT_1: SampleCount = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const SAMPLE_COUNT_2: SampleCount = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const SAMPLE_COUNT_4: SampleCount = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const SAMPLE_COUNT_8: SampleCount = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const SAMPLE_COUNT_16: SampleCount = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const SAMPLE_COUNT_COUNT: SampleCount = .{ .bits = @as(c_uint, @intCast(5)) };
    pub const SAMPLE_COUNT_ALL_BITS: SampleCount = .{ .bits = (@as(u32, @intCast(SampleCount.SAMPLE_COUNT_1.bits)) | @as(u32, @intCast(SampleCount.SAMPLE_COUNT_2.bits)) | @as(u32, @intCast(SampleCount.SAMPLE_COUNT_4.bits)) | @as(u32, @intCast(SampleCount.SAMPLE_COUNT_8.bits)) | @as(u32, @intCast(SampleCount.SAMPLE_COUNT_16.bits))) };

    // pub usingnamespace cpp.FlagsMixin(SampleCount);
};

pub const ShaderStage = extern struct {
    bits: c_int = 0,

    pub const SHADER_STAGE_NONE: ShaderStage = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SHADER_STAGE_VERT: ShaderStage = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const SHADER_STAGE_FRAG: ShaderStage = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const SHADER_STAGE_COMP: ShaderStage = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const SHADER_STAGE_GEOM: ShaderStage = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const SHADER_STAGE_TESC: ShaderStage = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const SHADER_STAGE_TESE: ShaderStage = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const SHADER_STAGE_ALL_GRAPHICS: ShaderStage = .{ .bits = (@as(u32, @intCast(ShaderStage.SHADER_STAGE_VERT.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_TESC.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_TESE.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_GEOM.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_FRAG.bits))) };
    pub const SHADER_STAGE_HULL: ShaderStage = .{ .bits = @as(c_uint, @intCast(ShaderStage.SHADER_STAGE_TESC.bits)) };
    pub const SHADER_STAGE_DOMN: ShaderStage = .{ .bits = @as(c_uint, @intCast(ShaderStage.SHADER_STAGE_TESE.bits)) };
    pub const SHADER_STAGE_WORKGRAPH: ShaderStage = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const SHADER_STAGE_COUNT: ShaderStage = .{ .bits = @as(c_uint, @intCast(7)) };

    // pub usingnamespace cpp.FlagsMixin(ShaderStage);
};

pub const TextureDimension = extern struct {
    bits: c_int = 0,

    pub const TEXTURE_DIM_1D: TextureDimension = .{ .bits = 0 };
    pub const TEXTURE_DIM_2D: TextureDimension = .{ .bits = 1 };
    pub const TEXTURE_DIM_2DMS: TextureDimension = .{ .bits = 2 };
    pub const TEXTURE_DIM_3D: TextureDimension = .{ .bits = 3 };
    pub const TEXTURE_DIM_CUBE: TextureDimension = .{ .bits = 4 };
    pub const TEXTURE_DIM_1D_ARRAY: TextureDimension = .{ .bits = 5 };
    pub const TEXTURE_DIM_2D_ARRAY: TextureDimension = .{ .bits = 6 };
    pub const TEXTURE_DIM_2DMS_ARRAY: TextureDimension = .{ .bits = 7 };
    pub const TEXTURE_DIM_CUBE_ARRAY: TextureDimension = .{ .bits = 8 };
    pub const TEXTURE_DIM_COUNT: TextureDimension = .{ .bits = 9 };
    pub const TEXTURE_DIM_UNDEFINED: TextureDimension = .{ .bits = 10 };

    // pub usingnamespace cpp.FlagsMixin(TextureDimension);
};

pub const PrimitiveTopology = extern struct {
    bits: c_int = 0,

    pub const PRIMITIVE_TOPO_POINT_LIST: PrimitiveTopology = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const PRIMITIVE_TOPO_LINE_LIST: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 1 };
    pub const PRIMITIVE_TOPO_LINE_STRIP: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 2 };
    pub const PRIMITIVE_TOPO_TRI_LIST: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 3 };
    pub const PRIMITIVE_TOPO_TRI_STRIP: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 4 };
    pub const PRIMITIVE_TOPO_PATCH_LIST: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 5 };
    pub const PRIMITIVE_TOPO_COUNT: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 6 };

    // pub usingnamespace cpp.FlagsMixin(PrimitiveTopology);
};

pub const IndexType = extern struct {
    bits: c_int = 0,

    pub const INDEX_TYPE_UINT32: IndexType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const INDEX_TYPE_UINT16: IndexType = .{ .bits = IndexType.INDEX_TYPE_UINT32.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(IndexType);
};

pub const ShaderSemantic = extern struct {
    bits: c_int = 0,

    pub const SEMANTIC_UNDEFINED: ShaderSemantic = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SEMANTIC_POSITION: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 1 };
    pub const SEMANTIC_NORMAL: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 2 };
    pub const SEMANTIC_COLOR: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 3 };
    pub const SEMANTIC_TANGENT: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 4 };
    pub const SEMANTIC_BITANGENT: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 5 };
    pub const SEMANTIC_JOINTS: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 6 };
    pub const SEMANTIC_WEIGHTS: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 7 };
    pub const SEMANTIC_CUSTOM: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 8 };
    pub const SEMANTIC_TEXCOORD0: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 9 };
    pub const SEMANTIC_TEXCOORD1: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 10 };
    pub const SEMANTIC_TEXCOORD2: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 11 };
    pub const SEMANTIC_TEXCOORD3: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 12 };
    pub const SEMANTIC_TEXCOORD4: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 13 };
    pub const SEMANTIC_TEXCOORD5: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 14 };
    pub const SEMANTIC_TEXCOORD6: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 15 };
    pub const SEMANTIC_TEXCOORD7: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 16 };
    pub const SEMANTIC_TEXCOORD8: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 17 };
    pub const SEMANTIC_TEXCOORD9: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 18 };
    pub const MAX_SEMANTICS: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 19 };

    // pub usingnamespace cpp.FlagsMixin(ShaderSemantic);
};

pub const BlendConstant = extern struct {
    bits: c_int = 0,

    pub const BC_ZERO: BlendConstant = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const BC_ONE: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 1 };
    pub const BC_SRC_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 2 };
    pub const BC_ONE_MINUS_SRC_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 3 };
    pub const BC_DST_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 4 };
    pub const BC_ONE_MINUS_DST_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 5 };
    pub const BC_SRC_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 6 };
    pub const BC_ONE_MINUS_SRC_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 7 };
    pub const BC_DST_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 8 };
    pub const BC_ONE_MINUS_DST_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 9 };
    pub const BC_SRC_ALPHA_SATURATE: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 10 };
    pub const BC_BLEND_FACTOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 11 };
    pub const BC_ONE_MINUS_BLEND_FACTOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 12 };
    pub const MAX_BLEND_CONSTANTS: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 13 };

    // pub usingnamespace cpp.FlagsMixin(BlendConstant);
};

pub const BlendMode = extern struct {
    bits: c_int = 0,

    pub const BM_ADD: BlendMode = .{ .bits = 0 };
    pub const BM_SUBTRACT: BlendMode = .{ .bits = 1 };
    pub const BM_REVERSE_SUBTRACT: BlendMode = .{ .bits = 2 };
    pub const BM_MIN: BlendMode = .{ .bits = 3 };
    pub const BM_MAX: BlendMode = .{ .bits = 4 };
    pub const MAX_BLEND_MODES: BlendMode = .{ .bits = 5 };

    // pub usingnamespace cpp.FlagsMixin(BlendMode);
};

pub const CompareMode = extern struct {
    bits: c_int = 0,

    pub const CMP_NEVER: CompareMode = .{ .bits = 0 };
    pub const CMP_LESS: CompareMode = .{ .bits = 1 };
    pub const CMP_EQUAL: CompareMode = .{ .bits = 2 };
    pub const CMP_LEQUAL: CompareMode = .{ .bits = 3 };
    pub const CMP_GREATER: CompareMode = .{ .bits = 4 };
    pub const CMP_NOTEQUAL: CompareMode = .{ .bits = 5 };
    pub const CMP_GEQUAL: CompareMode = .{ .bits = 6 };
    pub const CMP_ALWAYS: CompareMode = .{ .bits = 7 };
    pub const MAX_COMPARE_MODES: CompareMode = .{ .bits = 8 };

    // pub usingnamespace cpp.FlagsMixin(CompareMode);
};

pub const StencilOp = extern struct {
    bits: c_int = 0,

    pub const STENCIL_OP_KEEP: StencilOp = .{ .bits = 0 };
    pub const STENCIL_OP_SET_ZERO: StencilOp = .{ .bits = 1 };
    pub const STENCIL_OP_REPLACE: StencilOp = .{ .bits = 2 };
    pub const STENCIL_OP_INVERT: StencilOp = .{ .bits = 3 };
    pub const STENCIL_OP_INCR: StencilOp = .{ .bits = 4 };
    pub const STENCIL_OP_DECR: StencilOp = .{ .bits = 5 };
    pub const STENCIL_OP_INCR_SAT: StencilOp = .{ .bits = 6 };
    pub const STENCIL_OP_DECR_SAT: StencilOp = .{ .bits = 7 };
    pub const MAX_STENCIL_OPS: StencilOp = .{ .bits = 8 };

    // pub usingnamespace cpp.FlagsMixin(StencilOp);
};

pub const ColorMask = extern struct {
    bits: c_int = 0,

    pub const COLOR_MASK_NONE: ColorMask = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const COLOR_MASK_RED: ColorMask = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const COLOR_MASK_GREEN: ColorMask = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const COLOR_MASK_BLUE: ColorMask = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const COLOR_MASK_ALPHA: ColorMask = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const COLOR_MASK_ALL: ColorMask = .{ .bits = @as(c_uint, @intCast((ColorMask.COLOR_MASK_RED.bits | ColorMask.COLOR_MASK_GREEN.bits | ColorMask.COLOR_MASK_BLUE.bits | ColorMask.COLOR_MASK_ALPHA.bits))) };

    // pub usingnamespace cpp.FlagsMixin(ColorMask);
};

/// Blend states are always attached to one of the eight or more render targets that
/// are in a MRT
/// Mask constants
pub const BlendStateTargets = extern struct {
    bits: c_int = 0,

    pub const BLEND_STATE_TARGET_0: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const BLEND_STATE_TARGET_1: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const BLEND_STATE_TARGET_2: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const BLEND_STATE_TARGET_3: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const BLEND_STATE_TARGET_4: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const BLEND_STATE_TARGET_5: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const BLEND_STATE_TARGET_6: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const BLEND_STATE_TARGET_7: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const BLEND_STATE_TARGET_ALL: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(255)) };

    // pub usingnamespace cpp.FlagsMixin(BlendStateTargets);
};

/// Blend states are always attached to one of the eight or more render targets that
/// are in a MRT
/// Mask constants
pub const CullMode = extern struct {
    bits: c_int = 0,

    pub const CULL_MODE_NONE: CullMode = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const CULL_MODE_BACK: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 1 };
    pub const CULL_MODE_FRONT: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 2 };
    pub const CULL_MODE_BOTH: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 3 };
    pub const MAX_CULL_MODES: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 4 };

    // pub usingnamespace cpp.FlagsMixin(CullMode);
};

pub const FrontFace = extern struct {
    bits: c_int = 0,

    pub const FRONT_FACE_CCW: FrontFace = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FRONT_FACE_CW: FrontFace = .{ .bits = FrontFace.FRONT_FACE_CCW.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(FrontFace);
};

pub const FillMode = extern struct {
    bits: c_int = 0,

    pub const FILL_MODE_SOLID: FillMode = .{ .bits = 0 };
    pub const FILL_MODE_WIREFRAME: FillMode = .{ .bits = 1 };
    pub const MAX_FILL_MODES: FillMode = .{ .bits = 2 };

    // pub usingnamespace cpp.FlagsMixin(FillMode);
};

pub const PipelineType = extern struct {
    bits: c_int = 0,

    pub const PIPELINE_TYPE_UNDEFINED: PipelineType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const PIPELINE_TYPE_COMPUTE: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 1 };
    pub const PIPELINE_TYPE_GRAPHICS: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 2 };
    pub const PIPELINE_TYPE_WORKGRAPH: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 3 };
    pub const PIPELINE_TYPE_COUNT: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 4 };

    // pub usingnamespace cpp.FlagsMixin(PipelineType);
};

pub const FilterType = extern struct {
    bits: c_int = 0,

    pub const FILTER_NEAREST: FilterType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FILTER_LINEAR: FilterType = .{ .bits = FilterType.FILTER_NEAREST.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(FilterType);
};

pub const AddressMode = extern struct {
    bits: c_int = 0,

    pub const ADDRESS_MODE_MIRROR: AddressMode = .{ .bits = 0 };
    pub const ADDRESS_MODE_REPEAT: AddressMode = .{ .bits = 1 };
    pub const ADDRESS_MODE_CLAMP_TO_EDGE: AddressMode = .{ .bits = 2 };
    pub const ADDRESS_MODE_CLAMP_TO_BORDER: AddressMode = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(AddressMode);
};

pub const MipMapMode = extern struct {
    bits: c_int = 0,

    pub const MIPMAP_MODE_NEAREST: MipMapMode = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const MIPMAP_MODE_LINEAR: MipMapMode = .{ .bits = MipMapMode.MIPMAP_MODE_NEAREST.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(MipMapMode);
};

pub const ClearValue = extern union {
    __struct_field1: __Struct0,
    __struct_field3: __Struct2,

    pub const __Struct0 = extern struct {
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    };

    pub const __Struct2 = extern struct {
        depth: f32,
        stencil: u32,
    };
};

pub const BufferCreationFlags = extern struct {
    bits: c_int = 0,

    /// Default flag (Buffer will use aliased memory, buffer will not be cpu accessible until mapBuffer is called)
    pub const BUFFER_CREATION_FLAG_NONE: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Buffer will allocate its own memory (COMMITTED resource)
    pub const BUFFER_CREATION_FLAG_OWN_MEMORY_BIT: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Buffer will be persistently mapped
    pub const BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    /// Use ESRAM to store this buffer
    pub const BUFFER_CREATION_FLAG_ESRAM: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_NO_DESCRIPTOR_VIEW_CREATION: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_ACCELERATION_STRUCTURE_BUILD_INPUT: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_SHADER_BINDING_TABLE: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_MARKER: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(128)) };

    // pub usingnamespace cpp.FlagsMixin(BufferCreationFlags);
};

pub const TextureCreationFlags = extern struct {
    bits: c_int = 0,

    /// Default flag (Texture will use default allocation strategy decided by the api specific allocator)
    pub const TEXTURE_CREATION_FLAG_NONE: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Texture will allocate its own memory (COMMITTED resource)
    pub const TEXTURE_CREATION_FLAG_OWN_MEMORY_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Texture will be allocated in memory which can be shared among multiple processes
    pub const TEXTURE_CREATION_FLAG_EXPORT_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    /// Texture will be allocated in memory which can be shared among multiple gpus
    pub const TEXTURE_CREATION_FLAG_EXPORT_ADAPTER_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Texture will be imported from a handle created in another process
    pub const TEXTURE_CREATION_FLAG_IMPORT_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    /// Use ESRAM to store this texture
    pub const TEXTURE_CREATION_FLAG_ESRAM: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    /// Use on-tile memory to store this texture
    pub const TEXTURE_CREATION_FLAG_ON_TILE: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    /// Prevent compression meta data from generating (XBox)
    pub const TEXTURE_CREATION_FLAG_NO_COMPRESSION: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    /// Force 2D instead of automatically determining dimension based on width, height, depth
    pub const TEXTURE_CREATION_FLAG_FORCE_2D: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(128)) };
    /// Force 3D instead of automatically determining dimension based on width, height, depth
    pub const TEXTURE_CREATION_FLAG_FORCE_3D: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(256)) };
    /// Display target
    pub const TEXTURE_CREATION_FLAG_ALLOW_DISPLAY_TARGET: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(512)) };
    /// Create an sRGB texture.
    pub const TEXTURE_CREATION_FLAG_SRGB: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(1024)) };
    /// Create a normal map texture
    pub const TEXTURE_CREATION_FLAG_NORMAL_MAP: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(2048)) };
    /// Fast clear
    pub const TEXTURE_CREATION_FLAG_FAST_CLEAR: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(4096)) };
    /// Fragment mask
    pub const TEXTURE_CREATION_FLAG_FRAG_MASK: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(8192)) };
    /// Doubles the amount of array layers of the texture when rendering VR. Also forces the texture to be a 2D Array texture.
    pub const TEXTURE_CREATION_FLAG_VR_MULTIVIEW: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(16384)) };
    /// Binds the FFR fragment density if this texture is used as a render target.
    pub const TEXTURE_CREATION_FLAG_VR_FOVEATED_RENDERING: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(32768)) };
    pub const TEXTURE_CREATION_FLAG_SAMPLE_LOCATIONS_COMPATIBLE: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(131072)) };

    // pub usingnamespace cpp.FlagsMixin(TextureCreationFlags);
};

/// Used for swapchain
pub const ColorSpace = extern struct {
    bits: c_int = 0,

    pub const COLOR_SPACE_SDR_LINEAR: ColorSpace = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const COLOR_SPACE_SDR_SRGB: ColorSpace = .{ .bits = ColorSpace.COLOR_SPACE_SDR_LINEAR.bits + 1 };
    /// BT2020 color space with PQ EOTF
    pub const COLOR_SPACE_P2020: ColorSpace = .{ .bits = ColorSpace.COLOR_SPACE_SDR_LINEAR.bits + 2 };
    /// Extended sRGB with linear EOTF
    pub const COLOR_SPACE_EXTENDED_SRGB: ColorSpace = .{ .bits = ColorSpace.COLOR_SPACE_SDR_LINEAR.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(ColorSpace);
};

/// Used for swapchain
pub const BufferBarrier = extern struct {
    pBuffer: [*c]Buffer,
    mCurrentState: ResourceState,
    mNewState: ResourceState,
    bitfield_1: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mBeginOnly: u1, // 1 bits
        mEndOnly: u1, // 2 bits
        /// Padding added by c2z
        _dummy_padding: u6,
    },
};

pub const TextureBarrier = extern struct {
    pTexture: [*c]Texture,
    mCurrentState: ResourceState,
    mNewState: ResourceState,
    bitfield_1: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mBeginOnly: u1, // 1 bits
        mEndOnly: u1, // 2 bits
        mAcquire: u1, // 3 bits
        mRelease: u1, // 4 bits
        /// Padding added by c2z
        _dummy_padding: u4,
    },

    bitfield_2: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mQueueType: u5, // 5 bits
        /// Specifiy whether following barrier targets particular subresource
        mSubresourceBarrier: u1, // 6 bits
        /// Padding added by c2z
        _dummy_padding: u2,
    },

    bitfield_3: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Following values are ignored if mSubresourceBarrier is false
        mMipLevel: u7, // 7 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    mArrayLayer: u16,
};

pub const RenderTargetBarrier = extern struct {
    pRenderTarget: [*c]RenderTarget,
    mCurrentState: ResourceState,
    mNewState: ResourceState,
    bitfield_1: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mBeginOnly: u1, // 1 bits
        mEndOnly: u1, // 2 bits
        mAcquire: u1, // 3 bits
        mRelease: u1, // 4 bits
        /// Padding added by c2z
        _dummy_padding: u4,
    },

    bitfield_2: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mQueueType: u5, // 5 bits
        /// Specifiy whether following barrier targets particular subresource
        mSubresourceBarrier: u1, // 6 bits
        /// Padding added by c2z
        _dummy_padding: u2,
    },

    bitfield_3: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Following values are ignored if mSubresourceBarrier is false
        mMipLevel: u7, // 7 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    mArrayLayer: u16,
};

pub const ReadRange = extern struct {
    mOffset: u64,
    mSize: u64,
};

pub const QueryType = extern struct {
    bits: c_int = 0,

    pub const QUERY_TYPE_TIMESTAMP: QueryType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const QUERY_TYPE_OCCLUSION: QueryType = .{ .bits = QueryType.QUERY_TYPE_TIMESTAMP.bits + 1 };
    pub const QUERY_TYPE_PIPELINE_STATISTICS: QueryType = .{ .bits = QueryType.QUERY_TYPE_TIMESTAMP.bits + 2 };
    pub const QUERY_TYPE_COUNT: QueryType = .{ .bits = QueryType.QUERY_TYPE_TIMESTAMP.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(QueryType);
};

pub const QueryPoolDesc = extern struct {
    pName: [*c]const u8,
    mType: QueryType,
    mQueryCount: u32,
    mNodeIndex: u32,
};

pub const QueryDesc = extern struct {
    mIndex: u32,
};

pub const QueryPool = extern struct {
    mDx: __Struct0,
    mCount: u32,
    mStride: u32,

    pub const __Struct0 = extern struct {
        pQueryHeap: [*c]ID3D12QueryHeap,
        pReadbackBuffer: [*c]Buffer,
        mType: D3D12_QUERY_TYPE,
    };
};

pub const PipelineStatisticsQueryData = extern struct {
    mIAVertices: u64,
    mIAPrimitives: u64,
    mVSInvocations: u64,
    mGSInvocations: u64,
    mGSPrimitives: u64,
    mCInvocations: u64,
    mCPrimitives: u64,
    mPSInvocations: u64,
    mHSInvocations: u64,
    mDSInvocations: u64,
    mCSInvocations: u64,
};

pub const QueryData = extern struct {
    __union_field1: __Union0,
    mValid: bool,

    pub const __Union0 = extern union {
        __struct_field1: __Struct0,
        __struct_field3: __Struct2,
        mOcclusionCounts: u64,

        pub const __Struct0 = extern struct {
            mPipelineStats: PipelineStatisticsQueryData,
        };

        pub const __Struct2 = extern struct {
            mBeginTimestamp: u64,
            mEndTimestamp: u64,
        };
    };
};

pub const ResourceHeapCreationFlags = extern struct {
    bits: c_int = 0,

    pub const RESOURCE_HEAP_FLAG_NONE: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const RESOURCE_HEAP_FLAG_SHARED: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const RESOURCE_HEAP_FLAG_DENY_BUFFERS: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const RESOURCE_HEAP_FLAG_ALLOW_DISPLAY: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const RESOURCE_HEAP_FLAG_SHARED_CROSS_ADAPTER: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const RESOURCE_HEAP_FLAG_DENY_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const RESOURCE_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const RESOURCE_HEAP_FLAG_HARDWARE_PROTECTED: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const RESOURCE_HEAP_FLAG_ALLOW_WRITE_WATCH: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const RESOURCE_HEAP_FLAG_ALLOW_SHADER_ATOMICS: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(256)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(512)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ONLY_BUFFERS: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES.bits | ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_RT_DS_TEXTURES.bits)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_BUFFERS.bits | ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_RT_DS_TEXTURES.bits)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_BUFFERS.bits | ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES.bits)) };

    // pub usingnamespace cpp.FlagsMixin(ResourceHeapCreationFlags);
};

pub const ResourceHeapDesc = extern struct {
    mSize: u64,
    mAlignment: u64,
    mMemoryUsage: ResourceMemoryUsage,
    mDescriptors: DescriptorType,
    mFlags: ResourceHeapCreationFlags,
    mNodeIndex: u32,
    mSharedNodeIndexCount: u32,
    pSharedNodeIndices: [*c]u32,
    pName: [*c]const u8,
};

pub const ResourceHeap = extern struct {
    _: void align(64), // c2z: struct alignment
    mDx: __Struct0,
    mSize: u64,

    pub const __Struct0 = extern struct {
        pHeap: [*c]ID3D12Heap,
    };
};

comptime {
    // manual test that align works as intended
    std.debug.assert(@sizeOf(ResourceHeap) == 64);
}

pub const ResourceSizeAlign = extern struct {
    mSize: u64,
    mAlignment: u64,
};

pub const ResourcePlacement = extern struct {
    pHeap: [*c]ResourceHeap,
    mOffset: u64,
};

/// Data structure holding necessary info to create a Buffer
pub const BufferDesc = extern struct {
    /// Optional placement (addBuffer will place/bind buffer in this memory instead of allocating space)
    pPlacement: [*c]ResourcePlacement,
    /// Size of the buffer (in bytes)
    mSize: u64,
    /// Set this to specify a counter buffer for this buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    pCounterBuffer: [*c]Buffer,
    /// Index of the first element accessible by the SRV/UAV (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    mFirstElement: u32,
    /// Number of elements in the buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    mElementCount: u32,
    /// Size of each element (in bytes) in the buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    mStructStride: u32,
    /// Alignment
    mAlignment: u32,
    /// Debug name used in gpu profile
    pName: [*c]const u8,
    pSharedNodeIndices: [*c]u32,
    /// Decides which memory heap buffer will use (default, upload, readback)
    mMemoryUsage: ResourceMemoryUsage,
    /// Creation flags of the buffer
    mFlags: BufferCreationFlags,
    /// What type of queue the buffer is owned by
    mQueueType: QueueType,
    /// What state will the buffer get created in
    mStartState: ResourceState,
    /// ICB draw type
    mICBDrawType: IndirectArgumentType,
    /// ICB max commands in indirect command buffer
    mICBMaxCommandCount: u32,
    /// Format of the buffer (applicable to typed storage buffers (Buffer
    ///<T
    ///>)
    mFormat: TinyImageFormat,
    /// Flags specifying the suitable usage of this buffer (Uniform buffer, Vertex Buffer, Index Buffer,...)
    mDescriptors: DescriptorType,
    /// The index of the GPU in SLI/Cross-Fire that owns this buffer, or the Renderer index in unlinked mode.
    mNodeIndex: u32,
    mSharedNodeIndexCount: u32,
};

/// Data structure holding necessary info to create a Buffer
pub const Buffer = extern struct {
    _: void align(64), // c2z: struct alignment
    /// CPU address of the mapped buffer (applicable to buffers created in CPU accessible heaps (CPU, CPU_TO_GPU, GPU_TO_CPU)
    pCpuMappedAddress: ?*anyopaque,
    mDx: __Struct0,
    bitfield_1: packed struct(u64) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mSize: u32, // 32 bits
        mDescriptors: u20, // 52 bits
        mMemoryUsage: u3, // 55 bits
        mNodeIndex: u4, // 59 bits
        /// Padding added by c2z
        _dummy_padding: u5,
    },

    pub const __Struct0 = extern struct {
        /// GPU Address - Cache to avoid calls to ID3D12Resource::GetGpuVirtualAddress
        mGpuAddress: D3D12_GPU_VIRTUAL_ADDRESS,
        /// Descriptor handle of the CBV in a CPU visible descriptor heap (applicable to BUFFER_USAGE_UNIFORM)
        mDescriptors: DxDescriptorID,
        /// Offset from mDescriptors for srv descriptor handle
        mSrvDescriptorOffset: u8,
        /// Offset from mDescriptors for uav descriptor handle
        mUavDescriptorOffset: u8,
        bitfield_1: packed struct(u8) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            mMarkerBuffer: u1, // 1 bits
            /// Padding added by c2z
            _dummy_padding: u7,
        },

        /// Native handle of the underlying resource
        pResource: [*c]ID3D12Resource,
        __union_field1: __Union0,

        pub const __Union0 = extern union {
            pMarkerBufferHeap: [*c]ID3D12Heap,
            /// Contains resource allocation info such as parent heap, offset in heap
            pAllocation: [*c]D3D12MAAllocation_,

            // opaques

            const D3D12MAAllocation_ = anyopaque;
        };
    };
};

/// Data structure holding necessary info to create a Texture
pub const TextureDesc = extern struct {
    /// Optional placement (addTexture will place/bind buffer in this memory instead of allocating space)
    pPlacement: [*c]ResourcePlacement,
    /// Optimized clear value (recommended to use this same value when clearing the rendertarget)
    mClearValue: ClearValue,
    /// Pointer to native texture handle if the texture does not own underlying resource
    pNativeHandle: ?*const anyopaque,
    /// Debug name used in gpu profile
    pName: [*c]const u8,
    /// GPU indices to share this texture
    pSharedNodeIndices: [*c]u32,
    /// Texture creation flags (decides memory allocation strategy, sharing access,...)
    mFlags: TextureCreationFlags,
    /// Width
    mWidth: u32,
    /// Height
    mHeight: u32,
    /// Depth (Should be 1 if not a mType is not TEXTURE_TYPE_3D)
    mDepth: u32,
    /// Texture array size (Should be 1 if texture is not a texture array or cubemap)
    mArraySize: u32,
    /// Number of mip levels
    mMipLevels: u32,
    /// Number of multisamples per pixel (currently Textures created with mUsage TEXTURE_USAGE_SAMPLED_IMAGE only support SAMPLE_COUNT_1)
    mSampleCount: SampleCount,
    /// The image quality level. The higher the quality, the lower the performance. The valid range is between zero and the value
    /// appropriate for mSampleCount
    mSampleQuality: u32,
    ///  image format
    mFormat: TinyImageFormat,
    /// What state will the texture get created in
    mStartState: ResourceState,
    /// Descriptor creation
    mDescriptors: DescriptorType,
    /// Number of GPUs to share this texture
    mSharedNodeIndexCount: u32,
    /// GPU which will own this texture
    mNodeIndex: u32,
};

/// Data structure holding necessary info to create a Texture
pub const Texture = extern struct {
    _: void align(64), // c2z: struct alignment
    mDx: __Struct0,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Current state of the buffer
        mWidth: u16, // 16 bits
        mHeight: u16, // 32 bits
    },

    bitfield_2: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mDepth: u16, // 16 bits
        mMipLevels: u5, // 21 bits
        mArraySizeMinusOne: u11, // 32 bits
    },

    bitfield_3: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mFormat: u8, // 8 bits
        /// Flags specifying which aspects (COLOR,DEPTH,STENCIL) are included in the pImageView
        mAspectMask: u4, // 12 bits
        mNodeIndex: u4, // 16 bits
        mSampleCount: u5, // 21 bits
        mUav: u1, // 22 bits
        /// This value will be false if the underlying resource is not owned by the texture (swapchain textures,...)
        mOwnsImage: u1, // 23 bits
        /// Only applies to Vulkan but kept here as adding it inside mVk block increases the size of the struct and triggers assert below
        mLazilyAllocated: u1, // 24 bits
        /// Padding added by c2z
        _dummy_padding: u8,
    },

    pub const __Struct0 = extern struct {
        /// Descriptor handle of the SRV in a CPU visible descriptor heap (applicable to TEXTURE_USAGE_SAMPLED_IMAGE)
        mDescriptors: DxDescriptorID,
        /// Descriptor handle of the SRV in a CPU visible descriptor heap (applicable to TEXTURE_USAGE_SAMPLED_IMAGE when used along with
        /// mBindStencilResource)
        mStencilDescriptor: DxDescriptorID,
        /// Native handle of the underlying resource
        pResource: [*c]ID3D12Resource,
        /// Contains resource allocation info such as parent heap, offset in heap
        pAllocation: [*c]D3D12MAAllocation_,
        bitfield_1: packed struct(u32) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            mHandleCount: u24, // 24 bits
            /// Padding added by c2z
            _dummy_padding: u8,
        },

        mUavStartIndex: u32,
    };
};

pub const RenderTargetDesc = extern struct {
    /// Optional placement (addRenderTarget will place/bind buffer in this memory instead of allocating space)
    pPlacement: [*c]ResourcePlacement,
    /// Texture creation flags (decides memory allocation strategy, sharing access,...)
    mFlags: TextureCreationFlags,
    /// Width
    mWidth: u32,
    /// Height
    mHeight: u32,
    /// Depth (Should be 1 if not a mType is not TEXTURE_TYPE_3D)
    mDepth: u32,
    /// Texture array size (Should be 1 if texture is not a texture array or cubemap)
    mArraySize: u32,
    /// Number of mip levels
    mMipLevels: u32,
    /// MSAA
    mSampleCount: SampleCount,
    /// Internal image format
    mFormat: TinyImageFormat,
    /// What state will the texture get created in
    mStartState: ResourceState,
    /// Optimized clear value (recommended to use this same value when clearing the rendertarget)
    mClearValue: ClearValue,
    /// The image quality level. The higher the quality, the lower the performance. The valid range is between zero and the value
    /// appropriate for mSampleCount
    mSampleQuality: u32,
    /// Descriptor creation
    mDescriptors: DescriptorType,
    pNativeHandle: ?*const anyopaque,
    /// Debug name used in gpu profile
    pName: [*c]const u8,
    /// GPU indices to share this texture
    pSharedNodeIndices: [*c]u32,
    /// Number of GPUs to share this texture
    mSharedNodeIndexCount: u32,
    /// GPU which will own this texture
    mNodeIndex: u32,
};

pub const RenderTarget = extern struct {
    _: void align(64), // c2z: struct alignment
    pTexture: [*c]Texture,
    mDx: __Struct0,
    mClearValue: ClearValue,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mArraySize: u16, // 16 bits
        mDepth: u16, // 32 bits
    },

    bitfield_2: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mWidth: u16, // 16 bits
        mHeight: u16, // 32 bits
    },

    bitfield_3: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mDescriptors: u20, // 20 bits
        mMipLevels: u10, // 30 bits
        /// Padding added by c2z
        _dummy_padding: u2,
    },

    bitfield_4: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mSampleQuality: u5, // 5 bits
        /// Padding added by c2z
        _dummy_padding: u27,
    },

    mFormat: TinyImageFormat,
    mSampleCount: SampleCount,
    mVRMultiview: bool,
    mVRFoveatedRendering: bool,

    pub const __Struct0 = extern struct {
        mDescriptors: DxDescriptorID,
    };
};

pub const SampleLocations = extern struct {
    mX: i8,
    mY: i8,
};

pub const SamplerDesc = extern struct {
    mMinFilter: FilterType,
    mMagFilter: FilterType,
    mMipMapMode: MipMapMode,
    mAddressU: AddressMode,
    mAddressV: AddressMode,
    mAddressW: AddressMode,
    mMipLodBias: f32,
    mSetLodRange: bool,
    mMinLod: f32,
    mMaxLod: f32,
    mMaxAnisotropy: f32,
    mCompareFunc: CompareMode,
};

pub const Sampler = extern struct {
    _: void align(16), // c2z: struct alignment
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        /// Description for creating the Sampler descriptor for this sampler
        mDesc: D3D12_SAMPLER_DESC,
        /// Descriptor handle of the Sampler in a CPU visible descriptor heap
        mDescriptor: DxDescriptorID,
    };
};

pub const DescriptorDataRange = extern struct {
    mOffset: u32,
    mSize: u32,
    /// Specify different structured buffer stride (ignored for raw buffer - ByteAddressBuffer)
    mStructStride: u32,
};

pub const DescriptorData = extern struct {
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Number of array entries to update (array size of ppTextures/ppBuffers/...)
        mCount: u31, // 31 bits
        /// Binds stencil only descriptor instead of color/depth
        mBindStencilResource: u1, // 32 bits
    },

    bitfield_2: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Dst offset into the array descriptor (useful for updating few entries in a large array)
        /// Example: to update 6th entry in a bindless texture descriptor, mArrayOffset will be 6 and mCount will be 1)
        mArrayOffset: u20, // 20 bits
        /// Index in DescriptorSetDesc::pDescriptors array
        mIndex: u12, // 32 bits
    },

    /// Range to bind (buffer offset, size)
    pRanges: [*c]DescriptorDataRange,
    __union_field1: __Union0,
    __union_field3: __Union2,

    pub const __Union0 = extern union {
        __struct_field1: __Struct0,
        __struct_field3: __Struct2,

        pub const __Struct0 = extern struct {
            /// When binding UAV, control the mip slice to to bind for UAV (example - generating mipmaps in a compute shader)
            mUAVMipSlice: u16,
            /// Binds entire mip chain as array of UAV
            mBindMipChain: bool,
        };

        pub const __Struct2 = extern struct {
            /// Bind MTLIndirectCommandBuffer along with the MTLBuffer
            pICBName: [*c]const u8,
            mICBIndex: u32,
            mBindICB: bool,
        };
    };

    /// Array of resources containing descriptor handles or constant to be used in ring buffer memory - DescriptorRange can hold only one
    /// resource type array
    pub const __Union2 = extern union {
        /// Array of texture descriptors (srv and uav textures)
        ppTextures: [*c][*c]Texture,
        /// Array of sampler descriptors
        ppSamplers: [*c][*c]Sampler,
        /// Array of buffer descriptors (srv, uav and cbv buffers)
        ppBuffers: [*c][*c]Buffer,
        /// Custom binding (raytracing acceleration structure ...)
        ppAccelerationStructures: [*c][*c]AccelerationStructure,
    };
};

pub const DescriptorSet = extern struct {
    _: void align(64), // c2z: struct alignment
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        /// Start handle to cbv srv uav descriptor table
        mCbvSrvUavHandle: DxDescriptorID,
        /// Start handle to sampler descriptor table
        mSamplerHandle: DxDescriptorID,
        /// Stride of the cbv srv uav descriptor table (number of descriptors * descriptor size)
        mCbvSrvUavStride: u32,
        /// Stride of the sampler descriptor table (number of descriptors * descriptor size)
        mSamplerStride: u32,
        pDescriptors: [*c]const Descriptor,
        bitfield_1: packed struct(u32) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            mMaxSets: u16, // 16 bits
            mNodeIndex: u4, // 20 bits
            mCbvSrvUavRootIndex: u4, // 24 bits
            mSamplerRootIndex: u4, // 28 bits
            mPipelineType: u3, // 31 bits
            /// Padding added by c2z
            _dummy_padding: u1,
        },

        // opaques

        const Descriptor = anyopaque;
    };
};

pub const CmdPoolDesc = extern struct {
    pQueue: [*c]Queue,
    mTransient: bool,
};

pub const CmdPool = extern struct {
    pCmdAlloc: [*c]ID3D12CommandAllocator,
    pQueue: [*c]Queue,
};

pub const CmdDesc = extern struct {
    pPool: [*c]CmdPool,
    mSecondary: bool,
    pName: [*c]const u8,
};

pub const MarkerFlags = extern struct {
    bits: c_int = 0,

    /// Default flag
    pub const MARKER_FLAG_NONE: MarkerFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Default flag
    pub const MARKER_FLAG_WAIT_FOR_WRITE: MarkerFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(MarkerFlags);
};

pub const MarkerDesc = extern struct {
    pBuffer: [*c]Buffer,
    mOffset: u32,
    mValue: u32,
    mFlags: MarkerFlags,
};

pub const Cmd = extern struct {
    _: void align(64), // c2z: struct alignment
    mDx: __Struct0,
    pRenderer: [*c]Renderer,
    pQueue: [*c]Queue,

    pub const __Struct0 = extern struct {
        pCmdList: [*c]ID3D12GraphicsCommandList1,
        /// For resource state validation
        pDebugCmdList: [*c]ID3D12DebugCommandList,
        /// Cached in beginCmd to avoid fetching them during rendering
        pBoundHeaps: [2][*c]DescriptorHeap,
        mBoundHeapStartHandles: [2]D3D12_GPU_DESCRIPTOR_HANDLE,
        /// Command buffer state
        mBoundDescriptorSets: [8][2]D3D12_GPU_DESCRIPTOR_HANDLE,
        bitfield_1: packed struct(u32) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            mNodeIndex: u4, // 4 bits
            mType: u3, // 7 bits
            mPipelineType: u3, // 10 bits
            /// Padding added by c2z
            _dummy_padding: u22,
        },

        pCmdPool: [*c]CmdPool,

        // opaques

        const DescriptorHeap = anyopaque;
    };
};

pub const FenceStatus = extern struct {
    bits: c_int = 0,

    pub const FENCE_STATUS_COMPLETE: FenceStatus = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FENCE_STATUS_INCOMPLETE: FenceStatus = .{ .bits = FenceStatus.FENCE_STATUS_COMPLETE.bits + 1 };
    pub const FENCE_STATUS_NOTSUBMITTED: FenceStatus = .{ .bits = FenceStatus.FENCE_STATUS_COMPLETE.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(FenceStatus);
};

pub const Fence = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        pFence: [*c]ID3D12Fence,
        pWaitIdleFenceEvent: HANDLE,
        mFenceValue: u64,
    };
};

pub const Semaphore = extern struct {
    mDx: __Struct0,

    /// queuePresent does not use the wait semaphore since the swapchain Present function
    /// already does the synchronization in this case
    pub const __Struct0 = extern struct {
        pFence: [*c]ID3D12Fence,
        pWaitIdleFenceEvent: HANDLE,
        mFenceValue: u64,
    };
};

pub const QueueDesc = extern struct {
    mType: QueueType,
    mFlag: QueueFlag,
    mPriority: QueuePriority,
    mNodeIndex: u32,
    pName: [*c]const u8,
};

pub const Queue = extern struct {
    mDx: __Struct0,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mType: u3, // 3 bits
        mNodeIndex: u4, // 7 bits
        /// Padding added by c2z
        _dummy_padding: u25,
    },

    pub const __Struct0 = extern struct {
        pQueue: [*c]ID3D12CommandQueue,
        pFence: [*c]Fence,
        /// To silence mismatching command list on Windows 11 multi GPU
        pRenderer: [*c]Renderer,
    };
};

/// ShaderConstant only supported by Vulkan and Metal APIs
pub const ShaderConstant = extern struct {
    pValue: ?*const anyopaque,
    mIndex: u32,
    mSize: u32,
};

/// ShaderConstant only supported by Vulkan and Metal APIs
pub const BinaryShaderStageDesc = extern struct {
    pName: [*c]const u8,
    /// Byte code array
    pByteCode: ?*anyopaque,
    mByteCodeSize: u32,
    pEntryPoint: [*c]const u8,
};

pub const BinaryShaderDesc = extern struct {
    mStages: ShaderStage,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Specify whether shader will own byte code memory
        mOwnByteCode: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u31,
    },

    mVert: BinaryShaderStageDesc,
    mFrag: BinaryShaderStageDesc,
    mGeom: BinaryShaderStageDesc,
    mHull: BinaryShaderStageDesc,
    mDomain: BinaryShaderStageDesc,
    mComp: BinaryShaderStageDesc,
    pConstants: [*c]const ShaderConstant,
    mConstantCount: u32,
};

pub const Shader = extern struct {
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mStages: u31, // 31 bits
        /// C2Z WARNING: This perhaps shouldn't be padded in this way!
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    bitfield_2: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mIsMultiviewVR: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u7,
    },

    mNumThreadsPerGroup: [3]u32,
    mOutputRenderTargetTypesMask: u32,
    mDx: __Struct0,
    mNumControlPoints: u32,

    pub const __Struct0 = extern struct {
        pEntryNames: [*c]LPCWSTR,
        pVSBlob: [*c]IDxcBlobEncoding,
        pHSBlob: [*c]IDxcBlobEncoding,
        pDSBlob: [*c]IDxcBlobEncoding,
        pGSBlob: [*c]IDxcBlobEncoding,
        pPSBlob: [*c]IDxcBlobEncoding,
        pCSBlob: [*c]IDxcBlobEncoding,

        // opaques

        const IDxcBlobEncoding = anyopaque;
    };
};

pub const BlendStateDesc = extern struct {
    /// Source blend factor per render target.
    mSrcFactors: [8]BlendConstant,
    /// Destination blend factor per render target.
    mDstFactors: [8]BlendConstant,
    /// Source alpha blend factor per render target.
    mSrcAlphaFactors: [8]BlendConstant,
    /// Destination alpha blend factor per render target.
    mDstAlphaFactors: [8]BlendConstant,
    /// Blend mode per render target.
    mBlendModes: [8]BlendMode,
    /// Alpha blend mode per render target.
    mBlendAlphaModes: [8]BlendMode,
    /// Write mask per render target.
    mColorWriteMasks: [8]ColorMask,
    /// Mask that identifies the render targets affected by the blend state.
    mRenderTargetMask: BlendStateTargets,
    /// Set whether alpha to coverage should be enabled.
    mAlphaToCoverage: bool,
    /// Set whether each render target has an unique blend function. When false the blend function in slot 0 will be used for all render
    /// targets.
    mIndependentBlend: bool,
};

pub const DepthStateDesc = extern struct {
    mDepthTest: bool,
    mDepthWrite: bool,
    mDepthFunc: CompareMode,
    mStencilTest: bool,
    mStencilReadMask: u8,
    mStencilWriteMask: u8,
    mStencilFrontFunc: CompareMode,
    mStencilFrontFail: StencilOp,
    mDepthFrontFail: StencilOp,
    mStencilFrontPass: StencilOp,
    mStencilBackFunc: CompareMode,
    mStencilBackFail: StencilOp,
    mDepthBackFail: StencilOp,
    mStencilBackPass: StencilOp,
};

pub const RasterizerStateDesc = extern struct {
    mCullMode: CullMode,
    mDepthBias: i32,
    mSlopeScaledDepthBias: f32,
    mFillMode: FillMode,
    mFrontFace: FrontFace,
    mMultiSample: bool,
    mScissor: bool,
    mDepthClampEnable: bool,
};

pub const VertexBindingRate = extern struct {
    bits: c_int = 0,

    pub const VERTEX_BINDING_RATE_VERTEX: VertexBindingRate = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const VERTEX_BINDING_RATE_INSTANCE: VertexBindingRate = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const VERTEX_BINDING_RATE_COUNT: VertexBindingRate = .{ .bits = VertexBindingRate.VERTEX_BINDING_RATE_INSTANCE.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(VertexBindingRate);
};

pub const VertexBinding = extern struct {
    mStride: u32,
    mRate: VertexBindingRate,
};

pub const VertexAttrib = extern struct {
    mSemantic: ShaderSemantic,
    mSemanticNameLength: u32,
    mSemanticName: [128]u8,
    mFormat: TinyImageFormat,
    mBinding: u32,
    mLocation: u32,
    mOffset: u32,
};

pub const VertexLayout = extern struct {
    mBindings: [15]VertexBinding,
    mAttribs: [15]VertexAttrib,
    mBindingCount: u32,
    mAttribCount: u32,
};

pub const Descriptor = extern struct {
    pName: [*c]const u8,
    mSetIndex: u32,
    mType: DescriptorType,
    mCount: u32,
    mOffset: u32,
};

pub const DescriptorSetDesc = extern struct {
    mIndex: u32,
    mMaxSets: u32,
    mNodeIndex: u32,
    mDescriptorCount: u32,
    pDescriptors: [*c]const Descriptor,
};

pub const GraphicsPipelineDesc = extern struct {
    pShaderProgram: [*c]Shader,
    pVertexLayout: [*c]VertexLayout,
    pBlendState: [*c]BlendStateDesc,
    pDepthState: [*c]DepthStateDesc,
    pRasterizerState: [*c]RasterizerStateDesc,
    pColorFormats: [*c]TinyImageFormat,
    mRenderTargetCount: u32,
    mSampleCount: SampleCount,
    mSampleQuality: u32,
    mDepthStencilFormat: TinyImageFormat,
    mPrimitiveTopo: PrimitiveTopology,
    mSupportIndirectCommandBuffer: bool,
    mVRFoveatedRendering: bool,
    mUseCustomSampleLocations: bool,
};

pub const ComputePipelineDesc = extern struct {
    pShaderProgram: [*c]Shader,
};

pub const WorkgraphPipelineDesc = extern struct {
    pShaderProgram: [*c]Shader,
    pWorkgraphName: [*c]const u8,
};

pub const PipelineDesc = extern struct {
    __union_field1: __Union0,
    pCache: [*c]PipelineCache,
    pPipelineExtensions: ?*anyopaque,
    pName: [*c]const u8,
    mType: PipelineType,
    mExtensionCount: u32,

    pub const __Union0 = extern union {
        mComputeDesc: ComputePipelineDesc,
        mGraphicsDesc: GraphicsPipelineDesc,
        mWorkgraphDesc: WorkgraphPipelineDesc,
    };
};

pub const Pipeline = extern struct {
    _: void align(64), // c2z: struct alignment
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        __union_field1: __Union0,
        mType: PipelineType,
        mPrimitiveTopology: D3D_PRIMITIVE_TOPOLOGY,

        pub const __Union0 = extern union {
            pPipelineState: [*c]ID3D12PipelineState,
            __struct_field1: __Struct0,

            pub const __Struct0 = extern struct {
                pStateObject: [*c]ID3D12StateObject,
                pWorkgraphName: [*c]WCHAR,
            };
        };
    };
};

pub const PipelineCacheFlags = extern struct {
    bits: c_int = 0,

    pub const PIPELINE_CACHE_FLAG_NONE: PipelineCacheFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const PIPELINE_CACHE_FLAG_EXTERNALLY_SYNCHRONIZED: PipelineCacheFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(PipelineCacheFlags);
};

pub const PipelineCacheDesc = extern struct {
    /// Initial pipeline cache data (can be NULL which means empty pipeline cache)
    pData: ?*anyopaque,
    /// Initial pipeline cache size
    mSize: usize,
    mFlags: PipelineCacheFlags,
};

pub const PipelineCache = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        pLibrary: [*c]ID3D12PipelineLibrary,
        pData: ?*anyopaque,
    };
};

pub const WorkgraphDesc = extern struct {
    pPipeline: [*c]Pipeline,
};

pub const Workgraph = extern struct {
    pBackingBuffer: [*c]Buffer,
    pPipeline: [*c]Pipeline,
    mId: D3D12_PROGRAM_IDENTIFIER,
};

pub const DispatchGraphInputType = extern struct {
    bits: c_int = 0,

    pub const DISPATCH_GRAPH_INPUT_CPU: DispatchGraphInputType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const DISPATCH_GRAPH_INPUT_GPU: DispatchGraphInputType = .{ .bits = DispatchGraphInputType.DISPATCH_GRAPH_INPUT_CPU.bits + 1 };
    pub const DISPATCH_GRAPH_INPUT_COUNT: DispatchGraphInputType = .{ .bits = DispatchGraphInputType.DISPATCH_GRAPH_INPUT_CPU.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(DispatchGraphInputType);
};

pub const DispatchGraphDesc = extern struct {
    pWorkgraph: [*c]Workgraph,
    __union_field1: __Union0,
    mInputType: DispatchGraphInputType,
    mInitialize: bool,

    pub const __Union0 = extern union {
        __struct_field1: __Struct0,
        __struct_field3: __Struct2,

        pub const __Struct0 = extern struct {
            pInput: ?*anyopaque,
            mInputStride: u32,
        };

        pub const __Struct2 = extern struct {
            pInputBuffer: [*c]Buffer,
            mInputBufferOffset: u32,
        };
    };
};

pub const SwapChainCreationFlags = extern struct {
    bits: c_int = 0,

    pub const SWAP_CHAIN_CREATION_FLAG_NONE: SwapChainCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SWAP_CHAIN_CREATION_FLAG_ENABLE_FOVEATED_RENDERING_VR: SwapChainCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(SwapChainCreationFlags);
};

pub const SwapChainDesc = extern struct {
    /// Window handle
    mWindowHandle: WindowHandle,
    /// Queues which should be allowed to present
    ppPresentQueues: [*c][*c]Queue,
    /// Number of present queues
    mPresentQueueCount: u32,
    /// Number of backbuffers in this swapchain
    mImageCount: u32,
    /// Width of the swapchain
    mWidth: u32,
    /// Height of the swapchain
    mHeight: u32,
    /// Color format of the swapchain
    mColorFormat: TinyImageFormat,
    /// Clear value
    mColorClearValue: ClearValue,
    /// Swapchain creation flags
    mFlags: SwapChainCreationFlags,
    /// Set whether swap chain will be presented using vsync
    mEnableVsync: bool,
    /// We can toggle to using FLIP model if app desires.
    mUseFlipSwapEffect: bool,
    /// Optional colorspace for HDR
    mColorSpace: ColorSpace,
};

pub const SwapChain = extern struct {
    /// Render targets created from the swapchain back buffers
    ppRenderTargets: [*c][*c]RenderTarget,
    mDx: __Struct0,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mImageCount: u8, // 8 bits
        mEnableVsync: u1, // 9 bits
        mColorSpace: u4, // 13 bits
        mFormat: u8, // 21 bits
        /// Padding added by c2z
        _dummy_padding: u11,
    },

    pub const __Struct0 = extern struct {
        /// Use IDXGISwapChain3 for now since IDXGISwapChain4
        /// isn't supported by older devices.
        pSwapChain: [*c]IDXGISwapChain3,
        bitfield_1: packed struct(u32) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            /// Sync interval to specify how interval for vsync
            mSyncInterval: u3, // 3 bits
            mFlags: u10, // 13 bits
            /// Padding added by c2z
            _dummy_padding: u19,
        },
    };
};

pub const ShaderTarget = extern struct {
    bits: c_int = 0,

    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_5_1: ShaderTarget = .{ .bits = 0 };
    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_6_0: ShaderTarget = .{ .bits = 1 };
    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_6_1: ShaderTarget = .{ .bits = 2 };
    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_6_2: ShaderTarget = .{ .bits = 3 };
    /// required for Raytracing
    pub const SHADER_TARGET_6_3: ShaderTarget = .{ .bits = 4 };
    /// required for VRS
    pub const SHADER_TARGET_6_4: ShaderTarget = .{ .bits = 5 };

    // pub usingnamespace cpp.FlagsMixin(ShaderTarget);
};

pub const GpuMode = extern struct {
    bits: c_int = 0,

    pub const GPU_MODE_SINGLE: GpuMode = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const GPU_MODE_LINKED: GpuMode = .{ .bits = GpuMode.GPU_MODE_SINGLE.bits + 1 };
    pub const GPU_MODE_UNLINKED: GpuMode = .{ .bits = GpuMode.GPU_MODE_SINGLE.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(GpuMode);
};

pub const RendererDesc = extern struct {
    mDx: __Struct0,
    mShaderTarget: ShaderTarget,
    mGpuMode: GpuMode,
    /// Apps may want to query additional state for their applications. That information is transferred through here.
    pExtendedSettings: [*c]ExtendedSettings,
    /// Required when creating unlinked multiple renderers. Optional otherwise, can be used for explicit GPU selection.
    pContext: [*c]RendererContext,
    mGpuIndex: u32,
    /// This results in new validation not possible during API calls on the CPU, by creating patched shaders that have validation added
    /// directly to the shader. However, it can slow things down a lot, especially for applications with numerous PSOs. Time to see the
    /// first render frame may take several minutes
    mEnableGpuBasedValidation: bool,
    /// to align on PC on 40 bytes
    mPaddingA: bool,
    mPaddingB: bool,
    mPaddingC: bool,

    pub const __Struct0 = extern struct {
        mFeatureLevel: D3D_FEATURE_LEVEL,
    };
};

pub const GPUVendorPreset = extern struct {
    mVendorId: u32,
    mModelId: u32,
    /// Optional as not all gpu's have that. Default is : 0x00
    mRevisionId: u32,
    mPresetLevel: GPUPresetLevel,
    mVendorName: [256]u8,
    /// If GPU Name is missing then value will be empty string
    mGpuName: [256]u8,
    mGpuDriverVersion: [256]u8,
    mGpuDriverDate: [256]u8,
    mRTCoresCount: u32,
};

/// if you made change to this structure, please update GraphicsConfig.cpp FORMAT_CAPABILITY_COUNT
pub const FormatCapability = extern struct {
    bits: c_int = 0,

    pub const FORMAT_CAP_NONE: FormatCapability = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FORMAT_CAP_LINEAR_FILTER: FormatCapability = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const FORMAT_CAP_READ: FormatCapability = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const FORMAT_CAP_WRITE: FormatCapability = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const FORMAT_CAP_READ_WRITE: FormatCapability = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const FORMAT_CAP_RENDER_TARGET: FormatCapability = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const FORMAT_CAP_DEPTH_STENCIL: FormatCapability = .{ .bits = @as(c_uint, @intCast(32)) };

    // pub usingnamespace cpp.FlagsMixin(FormatCapability);
};

/// if you made change to this structure, please update GraphicsConfig.cpp FORMAT_CAPABILITY_COUNT
pub const WaveOpsSupportFlags = extern struct {
    bits: c_int = 0,

    pub const WAVE_OPS_SUPPORT_FLAG_NONE: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const WAVE_OPS_SUPPORT_FLAG_BASIC_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const WAVE_OPS_SUPPORT_FLAG_VOTE_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const WAVE_OPS_SUPPORT_FLAG_ARITHMETIC_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const WAVE_OPS_SUPPORT_FLAG_BALLOT_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const WAVE_OPS_SUPPORT_FLAG_SHUFFLE_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const WAVE_OPS_SUPPORT_FLAG_SHUFFLE_RELATIVE_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const WAVE_OPS_SUPPORT_FLAG_CLUSTERED_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const WAVE_OPS_SUPPORT_FLAG_QUAD_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const WAVE_OPS_SUPPORT_FLAG_PARTITIONED_BIT_NV: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const WAVE_OPS_SUPPORT_FLAG_ALL: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(2147483647)) };

    // pub usingnamespace cpp.FlagsMixin(WaveOpsSupportFlags);
};

pub const UMASupportFlags = extern struct {
    bits: c_int = 0,

    pub const UMA_SUPPORT_NONE: UMASupportFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const UMA_SUPPORT_READ: UMASupportFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const UMA_SUPPORT_WRITE: UMASupportFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const UMA_SUPPORT_READ_WRITE: UMASupportFlags = .{ .bits = @as(c_uint, @intCast(UMASupportFlags.UMA_SUPPORT_READ.bits | UMASupportFlags.UMA_SUPPORT_WRITE.bits)) };

    // pub usingnamespace cpp.FlagsMixin(UMASupportFlags);
};

pub const GpuDesc = extern struct {
    mDx: __Struct0,
    mFormatCaps: [239]FormatCapability,
    ///**********************************************************************************
    ///
    /// GPU Properties
    ///**********************************************************************************
    ///
    /// update availableGpuProperties, setDefaultGPUProperties in GraphicsConfig.cpp
    /// if you made changes to this list
    mVRAM: u64,
    mUniformBufferAlignment: u32,
    mUploadBufferAlignment: u32,
    mUploadBufferTextureAlignment: u32,
    mUploadBufferTextureRowAlignment: u32,
    mMaxVertexInputBindings: u32,
    mMaxRootSignatureDWORDS: u32,
    mWaveLaneCount: u32,
    mWaveOpsSupportFlags: WaveOpsSupportFlags,
    mGpuVendorPreset: GPUVendorPreset,
    mWaveOpsSupportedStageFlags: ShaderStage,
    mMaxTotalComputeThreads: u32,
    mMaxComputeThreads: [3]u32,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mMultiDrawIndirect: u1, // 1 bits
        mMultiDrawIndirectCount: u1, // 2 bits
        mRootConstant: u1, // 3 bits
        mIndirectRootConstant: u1, // 4 bits
        mBuiltinDrawID: u1, // 5 bits
        mIndirectCommandBuffer: u1, // 6 bits
        mROVsSupported: u1, // 7 bits
        mTessellationSupported: u1, // 8 bits
        mGeometryShaderSupported: u1, // 9 bits
        mGpuMarkers: u1, // 10 bits
        mHDRSupported: u1, // 11 bits
        mTimestampQueries: u1, // 12 bits
        mOcclusionQueries: u1, // 13 bits
        mPipelineStatsQueries: u1, // 14 bits
        mAllowBufferTextureInSameHeap: u1, // 15 bits
        mRaytracingSupported: u1, // 16 bits
        mUnifiedMemorySupport: u2, // 18 bits
        mRayPipelineSupported: u1, // 19 bits
        mRayQuerySupported: u1, // 20 bits
        mWorkgraphSupported: u1, // 21 bits
        mSoftwareVRSSupported: u1, // 22 bits
        mPrimitiveIdSupported: u1, // 23 bits
        mPrimitiveIdPsSupported: u1, // 24 bits
        m64BitAtomicsSupported: u1, // 25 bits
        /// Padding added by c2z
        _dummy_padding: u7,
    },

    mFeatureLevel: D3D_FEATURE_LEVEL,
    bitfield_2: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mSuppressInvalidSubresourceStateAfterExit: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u31,
    },

    mMaxBoundTextures: u32,
    bitfield_3: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mSamplerAnisotropySupported: u1, // 1 bits
        mGraphicsQueueSupported: u1, // 2 bits
        /// Padding added by c2z
        _dummy_padding: u30,
    },

    mAmdAsicFamily: u32,
    mFrameBufferSamplesCount: u32,
    mGPUTarget: u32,

    pub const __Struct0 = extern struct {
        pGpu: [*c]IDXGIAdapter4,
    };
};

pub const Renderer = extern struct {
    _: void align(64), // c2z: struct alignment
    mDx: __Struct0,
    pNullDescriptors: [*c]NullDescriptors,
    pContext: [*c]RendererContext,
    pGpu: [*c]const GpuDesc,
    pName: [*c]const u8,
    mRendererApi: RendererApi,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mLinkedNodeCount: u4, // 4 bits
        mUnlinkedRendererIndex: u4, // 8 bits
        mGpuMode: u3, // 11 bits
        mShaderTarget: u4, // 15 bits
        mOwnsContext: u1, // 16 bits
        /// Padding added by c2z
        _dummy_padding: u16,
    },

    pub const __Struct0 = extern struct {
        /// API specific descriptor heap and memory allocator
        pCPUDescriptorHeaps: [*c][*c]DescriptorHeap,
        pCbvSrvUavHeaps: [*c][*c]DescriptorHeap,
        pSamplerHeaps: [*c][*c]DescriptorHeap,
        pResourceAllocator: [*c]D3D12MAAllocator_,
        /// Filled by user - See initGraphicsRootSignature, initComputeRootSignature
        pGraphicsRootSignature: [*c]ID3D12RootSignature,
        pComputeRootSignature: [*c]ID3D12RootSignature,
        pDevice: [*c]ID3D12Device,
        pDebugValidation: [*c]ID3D12InfoQueue1,
        mCallbackCookie: DWORD,
        mUseDebugCallback: bool,
        mSuppressMismatchingCommandListDuringPresent: bool,

        // opaques

        const D3D12MAAllocator_ = anyopaque;
    };

    // opaques

    const NullDescriptors = anyopaque;
};

pub const RendererContextDesc = extern struct {
    mDx: __Struct0,
    mEnableGpuBasedValidation: bool,

    pub const __Struct0 = extern struct {
        mFeatureLevel: D3D_FEATURE_LEVEL,
    };
};

pub const RendererContext = extern struct {
    mDx: __Struct0,
    mGpus: [4]GpuDesc,
    mGpuCount: u32,

    pub const __Struct0 = extern struct {
        pDXGIFactory: [*c]IDXGIFactory6,
        pDebug: [*c]ID3D12Debug,
    };
};

pub const QueueSubmitDesc = extern struct {
    ppCmds: [*c][*c]Cmd,
    pSignalFence: [*c]Fence,
    ppWaitSemaphores: [*c][*c]Semaphore,
    ppSignalSemaphores: [*c][*c]Semaphore,
    mCmdCount: u32,
    mWaitSemaphoreCount: u32,
    mSignalSemaphoreCount: u32,
    mSubmitDone: bool,
};

pub const QueuePresentDesc = extern struct {
    pSwapChain: [*c]SwapChain,
    ppWaitSemaphores: [*c][*c]Semaphore,
    mWaitSemaphoreCount: u32,
    mIndex: u8,
    mSubmitDone: bool,
};

pub const BindRenderTargetDesc = extern struct {
    pRenderTarget: [*c]RenderTarget,
    mLoadAction: LoadActionType,
    mStoreAction: StoreActionType,
    mClearValue: ClearValue,
    mLoadActionStencil: LoadActionType,
    mStoreActionStencil: StoreActionType,
    mArraySlice: u32,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mMipSlice: u10, // 10 bits
        mOverrideClearValue: u1, // 11 bits
        mUseArraySlice: u1, // 12 bits
        mUseMipSlice: u1, // 13 bits
        /// Padding added by c2z
        _dummy_padding: u19,
    },
};

pub const BindDepthTargetDesc = extern struct {
    pDepthStencil: [*c]RenderTarget,
    mLoadAction: LoadActionType,
    mLoadActionStencil: LoadActionType,
    mStoreAction: StoreActionType,
    mStoreActionStencil: StoreActionType,
    mClearValue: ClearValue,
    mArraySlice: u32,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mMipSlice: u10, // 10 bits
        mOverrideClearValue: u1, // 11 bits
        mUseArraySlice: u1, // 12 bits
        mUseMipSlice: u1, // 13 bits
        /// Padding added by c2z
        _dummy_padding: u19,
    },
};

/// Uses render targets' sample count in bindRenderTargetsDesc
pub const SampleLocationDesc = extern struct {
    pLocations: [*c]SampleLocations,
    mGridSizeX: u32,
    mGridSizeY: u32,
};

/// Uses render targets' sample count in bindRenderTargetsDesc
pub const BindRenderTargetsDesc = extern struct {
    mRenderTargetCount: u32,
    mRenderTargets: [8]BindRenderTargetDesc,
    mDepthStencil: BindDepthTargetDesc,
    mSampleLocation: SampleLocationDesc,
    /// Explicit viewport for empty render pass
    mExtent: [2]u32,
};

/// Multiple renderer API (optional)
pub extern fn initRendererContext(appName: [*c]const u8, pSettings: [*c]const RendererContextDesc, ppContext: [*c][*c]RendererContext) void;
pub extern fn exitRendererContext(pContext: [*c]RendererContext) void;
/// allocates memory and initializes the renderer -> returns pRenderer
pub extern fn initRenderer(appName: [*c]const u8, pSettings: [*c]const RendererDesc, ppRenderer: [*c][*c]Renderer) void;
pub extern fn exitRenderer(pRenderer: [*c]Renderer) void;
pub extern fn initFence(pRenderer: [*c]Renderer, ppFence: [*c][*c]Fence) void;
pub extern fn exitFence(pRenderer: [*c]Renderer, pFence: [*c]Fence) void;
pub extern fn initSemaphore(pRenderer: [*c]Renderer, ppSemaphore: [*c][*c]Semaphore) void;
pub extern fn exitSemaphore(pRenderer: [*c]Renderer, pSemaphore: [*c]Semaphore) void;
pub extern fn initQueue(pRenderer: [*c]Renderer, pQDesc: [*c]QueueDesc, ppQueue: [*c][*c]Queue) void;
pub extern fn exitQueue(pRenderer: [*c]Renderer, pQueue: [*c]Queue) void;
pub extern fn addSwapChain(pRenderer: [*c]Renderer, pDesc: [*c]const SwapChainDesc, ppSwapChain: [*c][*c]SwapChain) void;
pub extern fn removeSwapChain(pRenderer: [*c]Renderer, pSwapChain: [*c]SwapChain) void;
/// memory functions
pub extern fn addResourceHeap(pRenderer: [*c]Renderer, pDesc: [*c]const ResourceHeapDesc, ppHeap: [*c][*c]ResourceHeap) void;
pub extern fn removeResourceHeap(pRenderer: [*c]Renderer, pHeap: [*c]ResourceHeap) void;
/// command pool functions
pub extern fn initCmdPool(pRenderer: [*c]Renderer, pDesc: [*c]const CmdPoolDesc, ppCmdPool: [*c][*c]CmdPool) void;
pub extern fn exitCmdPool(pRenderer: [*c]Renderer, pCmdPool: [*c]CmdPool) void;
pub extern fn initCmd(pRenderer: [*c]Renderer, pDesc: [*c]const CmdDesc, ppCmd: [*c][*c]Cmd) void;
pub extern fn exitCmd(pRenderer: [*c]Renderer, pCmd: [*c]Cmd) void;
pub extern fn initCmd_n(pRenderer: [*c]Renderer, pDesc: [*c]const CmdDesc, cmdCount: u32, pppCmds: [*c][*c][*c]Cmd) void;
pub extern fn exitCmd_n(pRenderer: [*c]Renderer, cmdCount: u32, ppCmds: [*c][*c]Cmd) void;
/// All buffer, texture loading handled by resource system -> IResourceLoader.*
pub extern fn addRenderTarget(pRenderer: [*c]Renderer, pDesc: [*c]const RenderTargetDesc, ppRenderTarget: [*c][*c]RenderTarget) void;
pub extern fn removeRenderTarget(pRenderer: [*c]Renderer, pRenderTarget: [*c]RenderTarget) void;
pub extern fn addSampler(pRenderer: [*c]Renderer, pDesc: [*c]const SamplerDesc, ppSampler: [*c][*c]Sampler) void;
pub extern fn removeSampler(pRenderer: [*c]Renderer, pSampler: [*c]Sampler) void;
/// shader functions
pub extern fn addShaderBinary(pRenderer: [*c]Renderer, pDesc: [*c]const BinaryShaderDesc, ppShaderProgram: [*c][*c]Shader) void;
pub extern fn removeShader(pRenderer: [*c]Renderer, pShaderProgram: [*c]Shader) void;
/// pipeline functions
pub extern fn addPipeline(pRenderer: [*c]Renderer, pPipelineSettings: [*c]const PipelineDesc, ppPipeline: [*c][*c]Pipeline) void;
pub extern fn removePipeline(pRenderer: [*c]Renderer, pPipeline: [*c]Pipeline) void;
pub extern fn addPipelineCache(pRenderer: [*c]Renderer, pDesc: [*c]const PipelineCacheDesc, ppPipelineCache: [*c][*c]PipelineCache) void;
pub extern fn getPipelineCacheData(pRenderer: [*c]Renderer, pPipelineCache: [*c]PipelineCache, pSize: [*c]usize, pData: ?*anyopaque) void;
pub extern fn removePipelineCache(pRenderer: [*c]Renderer, pPipelineCache: [*c]PipelineCache) void;
/// Descriptor Set functions
pub extern fn addDescriptorSet(pRenderer: [*c]Renderer, pDesc: [*c]const DescriptorSetDesc, ppDescriptorSet: [*c][*c]DescriptorSet) void;
pub extern fn removeDescriptorSet(pRenderer: [*c]Renderer, pDescriptorSet: [*c]DescriptorSet) void;
pub extern fn updateDescriptorSet(pRenderer: [*c]Renderer, index: u32, pDescriptorSet: [*c]DescriptorSet, count: u32, pParams: [*c]const DescriptorData) void;
/// command buffer functions
pub extern fn resetCmdPool(pRenderer: [*c]Renderer, pCmdPool: [*c]CmdPool) void;
pub extern fn beginCmd(pCmd: [*c]Cmd) void;
pub extern fn endCmd(pCmd: [*c]Cmd) void;
pub extern fn cmdBindRenderTargets(pCmd: [*c]Cmd, pDesc: [*c]const BindRenderTargetsDesc) void;
pub extern fn cmdSetViewport(pCmd: [*c]Cmd, x: f32, y: f32, width: f32, height: f32, minDepth: f32, maxDepth: f32) void;
pub extern fn cmdSetScissor(pCmd: [*c]Cmd, x: u32, y: u32, width: u32, height: u32) void;
pub extern fn cmdSetStencilReferenceValue(pCmd: [*c]Cmd, val: u32) void;
pub extern fn cmdBindPipeline(pCmd: [*c]Cmd, pPipeline: [*c]Pipeline) void;
pub extern fn cmdBindDescriptorSet(pCmd: [*c]Cmd, index: u32, pDescriptorSet: [*c]DescriptorSet) void;
pub extern fn cmdBindIndexBuffer(pCmd: [*c]Cmd, pBuffer: [*c]Buffer, indexType: u32, offset: u64) void;
pub extern fn cmdBindVertexBuffer(pCmd: [*c]Cmd, bufferCount: u32, ppBuffers: [*c][*c]Buffer, pStrides: [*c]const u32, pOffsets: [*c]const u64) void;
pub extern fn cmdDraw(pCmd: [*c]Cmd, vertexCount: u32, firstVertex: u32) void;
pub extern fn cmdDrawInstanced(pCmd: [*c]Cmd, vertexCount: u32, firstVertex: u32, instanceCount: u32, firstInstance: u32) void;
pub extern fn cmdDrawIndexed(pCmd: [*c]Cmd, indexCount: u32, firstIndex: u32, firstVertex: u32) void;
pub extern fn cmdDrawIndexedInstanced(pCmd: [*c]Cmd, indexCount: u32, firstIndex: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) void;
pub extern fn cmdDispatch(pCmd: [*c]Cmd, groupCountX: u32, groupCountY: u32, groupCountZ: u32) void;
/// Transition Commands
pub extern fn cmdResourceBarrier(pCmd: [*c]Cmd, bufferBarrierCount: u32, pBufferBarriers: [*c]BufferBarrier, textureBarrierCount: u32, pTextureBarriers: [*c]TextureBarrier, rtBarrierCount: u32, pRtBarriers: [*c]RenderTargetBarrier) void;
/// queue/fence/swapchain functions
pub extern fn acquireNextImage(pRenderer: [*c]Renderer, pSwapChain: [*c]SwapChain, pSignalSemaphore: [*c]Semaphore, pFence: [*c]Fence, pImageIndex: [*c]u32) void;
pub extern fn queueSubmit(pQueue: [*c]Queue, pDesc: [*c]const QueueSubmitDesc) void;
pub extern fn queuePresent(pQueue: [*c]Queue, pDesc: [*c]const QueuePresentDesc) void;
pub extern fn waitQueueIdle(pQueue: [*c]Queue) void;
pub extern fn getFenceStatus(pRenderer: [*c]Renderer, pFence: [*c]Fence, pFenceStatus: [*c]FenceStatus) void;
pub extern fn waitForFences(pRenderer: [*c]Renderer, fenceCount: u32, ppFences: [*c][*c]Fence) void;
pub extern fn toggleVSync(pRenderer: [*c]Renderer, ppSwapchain: [*c][*c]SwapChain) void;
///Returns the recommended format for the swapchain.
///If true is passed for the hintHDR parameter, it will return an HDR format IF the platform supports it
///If false is passed or the platform does not support HDR a non HDR format is returned.
///If true is passed for the hintSrgb parameter, it will return format that is will do gamma correction automatically
///If false is passed for the hintSrgb parameter the gamma correction should be done as a postprocess step before submitting image to swapchain
pub extern fn getSupportedSwapchainFormat(pRenderer: [*c]Renderer, pDesc: [*c]const SwapChainDesc, colorSpace: ColorSpace) TinyImageFormat;
pub extern fn getRecommendedSwapchainImageCount(pRenderer: [*c]Renderer, hwnd: [*c]const WindowHandle) u32;
///indirect Draw functions
pub extern fn cmdExecuteIndirect(pCmd: [*c]Cmd, type: IndirectArgumentType, maxCommandCount: c_uint, pIndirectBuffer: [*c]Buffer, bufferOffset: u64, pCounterBuffer: [*c]Buffer, counterBufferOffset: u64) void;
pub extern fn addWorkgraph(pRenderer: [*c]Renderer, pDesc: [*c]const WorkgraphDesc, ppWorkgraph: [*c][*c]Workgraph) void;
pub extern fn removeWorkgraph(pRenderer: [*c]Renderer, pWorkgraph: [*c]Workgraph) void;
pub extern fn cmdDispatchWorkgraph(pCmd: [*c]Cmd, pDesc: [*c]const DispatchGraphDesc) void;
///*********************************************************************
///
/// GPU Query Interface
///*********************************************************************
pub extern fn getTimestampFrequency(pQueue: [*c]Queue, pFrequency: [*c]f64) void;
pub extern fn initQueryPool(pRenderer: [*c]Renderer, pDesc: [*c]const QueryPoolDesc, ppQueryPool: [*c][*c]QueryPool) void;
pub extern fn exitQueryPool(pRenderer: [*c]Renderer, pQueryPool: [*c]QueryPool) void;
pub extern fn cmdBeginQuery(pCmd: [*c]Cmd, pQueryPool: [*c]QueryPool, pQuery: [*c]QueryDesc) void;
pub extern fn cmdEndQuery(pCmd: [*c]Cmd, pQueryPool: [*c]QueryPool, pQuery: [*c]QueryDesc) void;
pub extern fn cmdResolveQuery(pCmd: [*c]Cmd, pQueryPool: [*c]QueryPool, startQuery: u32, queryCount: u32) void;
pub extern fn cmdResetQuery(pCmd: [*c]Cmd, pQueryPool: [*c]QueryPool, startQuery: u32, queryCount: u32) void;
pub extern fn getQueryData(pRenderer: [*c]Renderer, pQueryPool: [*c]QueryPool, queryIndex: u32, pOutData: [*c]QueryData) void;
///*********************************************************************
///
/// Stats Info Interface
///*********************************************************************
pub extern fn logMemoryStats(pRenderer: [*c]Renderer) void;
pub extern fn calculateMemoryUse(pRenderer: [*c]Renderer, usedBytes: [*c]u64, totalAllocatedBytes: [*c]u64) void;
///*********************************************************************
///
/// Debug Marker Interface
///*********************************************************************
pub extern fn cmdBeginDebugMarker(pCmd: [*c]Cmd, r: f32, g: f32, b: f32, pName: [*c]const u8) void;
pub extern fn cmdEndDebugMarker(pCmd: [*c]Cmd) void;
pub extern fn cmdAddDebugMarker(pCmd: [*c]Cmd, r: f32, g: f32, b: f32, pName: [*c]const u8) void;
pub extern fn cmdWriteMarker(pCmd: [*c]Cmd, pDesc: [*c]const MarkerDesc) void;
///*********************************************************************
///
/// Resource Debug Naming Interface
///*********************************************************************
pub extern fn setBufferName(pRenderer: [*c]Renderer, pBuffer: [*c]Buffer, pName: [*c]const u8) void;
pub extern fn setTextureName(pRenderer: [*c]Renderer, pTexture: [*c]Texture, pName: [*c]const u8) void;
pub extern fn setRenderTargetName(pRenderer: [*c]Renderer, pRenderTarget: [*c]RenderTarget, pName: [*c]const u8) void;
pub extern fn setPipelineName(pRenderer: [*c]Renderer, pPipeline: [*c]Pipeline, pName: [*c]const u8) void;

// opaques

const RaytracingHitGroup = anyopaque;
const DescriptorIndexMap = anyopaque;
const Raytracing = anyopaque;
const EsramManager = anyopaque;
const AccelerationStructure = anyopaque;

// unnamed nodes

pub const UnnamedEnum0 = extern struct {
    bits: c_int = 0,

    pub const MAX_INSTANCE_EXTENSIONS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const MAX_DEVICE_EXTENSIONS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(64)) };
    /// Max number of GPUs in SLI or Cross-Fire
    pub const MAX_LINKED_GPUS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Max number of GPUs in unlinked mode
    pub const MAX_UNLINKED_GPUS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_MULTIPLE_GPUS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_RENDER_TARGET_ATTACHMENTS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(8)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_VERTEX_BINDINGS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(15)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_VERTEX_ATTRIBS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(15)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_RESOURCE_NAME_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(256)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_SEMANTIC_NAME_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(128)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_DEBUG_NAME_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(128)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_MIP_LEVELS: UnnamedEnum0 = .{ .bits = 4294967295 };
    /// max size for GPUVendorPreset strings
    pub const MAX_GPU_VENDOR_STRING_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const MAX_SAMPLE_LOCATIONS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const MAX_PUSH_CONSTANTS_32BIT_COUNT: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const MAX_DESCRIPTOR_TABLES: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(8)) };

    // pub usingnamespace cpp.FlagsMixin(UnnamedEnum0);
};
