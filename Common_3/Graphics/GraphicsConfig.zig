// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

/// ------------------------------- gpu configuration rules ------------------------------- //
pub const GpuDesc = extern struct {};

pub const ExtendedSettings = extern struct {
    mNumSettings: u32,
    pSettings: [*c]u32,
    ppSettingNames: [*c]const [*c]u8,
};

pub const GPUPresetLevel = extern struct {
    bits: c_int = 0,

    pub const GPU_PRESET_NONE: GPUPresetLevel = .{ .bits = @as(c_uint, @intCast(0)) };
    /// This means unsupported
    pub const GPU_PRESET_OFFICE: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 1 };
    /// Mostly for mobile GPU
    pub const GPU_PRESET_VERYLOW: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 2 };
    pub const GPU_PRESET_LOW: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 3 };
    pub const GPU_PRESET_MEDIUM: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 4 };
    pub const GPU_PRESET_HIGH: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 5 };
    pub const GPU_PRESET_ULTRA: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 6 };
    pub const GPU_PRESET_COUNT: GPUPresetLevel = .{ .bits = GPUPresetLevel.GPU_PRESET_NONE.bits + 7 };

    // pub usingnamespace cpp.FlagsMixin(GPUPresetLevel);
};

/// read gpu.cfg and store all its content in specific structures
pub extern fn addGPUConfigurationRules(pExtendedSettings: [*c]ExtendedSettings) void;
/// free all specific gpu.cfg structures
pub extern fn removeGPUConfigurationRules() void;
/// set default value, samplerAnisotropySupported, graphicsQueueSupported, primitiveID
pub extern fn setDefaultGPUProperties(pGpuDesc: [*c]GpuDesc) void;
/// selects best gpu depending on the gpu comparison rules stored in gpu.cfg
pub extern fn util_select_best_gpu(availableSettings: [*c]GpuDesc, gpuCount: u32) u32;
/// Check if the selected gpu is supported based on the GPUCfg rules.
pub extern fn util_check_is_gpu_supported(gpuSettings: [*c]GpuDesc) bool;
/// reads the gpu data and sets the preset level of all available gpu's
pub extern fn getDefaultPresetLevel() GPUPresetLevel;
pub extern fn getGPUPresetLevel(vendorId: u32, modelId: u32, vendorName: [*c]const u8, modelName: [*c]const u8) GPUPresetLevel;
/// apply the configuration rules stored in gpu.cfg to to a single GPUSettings and GPUCapBits
pub extern fn applyGPUConfigurationRules(pGpuSettings: [*c]GpuDesc) void;
/// apply the user extended configuration rules stored in gpu.cfg to the ExtendedSetting structure
pub extern fn setupGPUConfigurationExtendedSettings(pExtendedSettings: [*c]ExtendedSettings, pGpuDesc: [*c]const GpuDesc) void;
pub extern fn setupGPUConfigurationPlatformParameters(pRenderer: [*c]Renderer, pExtendedSettings: [*c]ExtendedSettings) void;
pub extern fn initGPUConfiguration(pExtendedSettings: [*c]ExtendedSettings) void;
pub extern fn exitGPUConfiguration() void;
/// Scene resolution is the resolution at which we want to render and shade the scene (world, terrain, ... skybox)
/// This needs to be customized based on the performance requirements and the hardware preset, user settings, ...
/// Usually, we render the scene at different resolution (sometimes lower than native) and UI at native resolution or close to native
/// resolution
/// Example: We might render the scene at 720p on a low-end mobile device but we would still want higher res UI
/// On a high-end console, we might render the scene at display resolution as the GPU is powerful enough
pub extern fn getGPUCfgSceneResolution(displayWidth: u32, displayHeight: u32) Resolution;
/// return if the the GpuDesc validate the current driver rejection rules
pub extern fn checkDriverRejectionSettings(pGpuDesc: [*c]const GpuDesc) bool;
/// ------ utilities ------
pub extern fn presetLevelToString(preset: GPUPresetLevel) [*c]const u8;
pub extern fn stringToPresetLevel(presetLevel: [*c]const u8) GPUPresetLevel;
pub extern fn gpuVendorEquals(vendorId: u32, vendorName: [*c]const u8) bool;
pub extern fn getGPUVendorName(modelId: u32) [*c]const u8;
pub extern fn getGPUVendorID(__arg0: [*c]const u8) u32;
pub extern fn getUnsupportedGPUMsg() [*c]const u8;

// opaques

const Renderer = anyopaque;
